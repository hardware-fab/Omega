#!/usr/bin/python3

#----------------------------------------------------------------------------
#  This file is a part of the VESPA SoC Prototyping Framework
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the Apache 2.0 License.
#
# File:    DPR_exploration.py
# Authors: Gabriele Montanaro
#          Andrea Galimberti
#          Davide Zoni
# Company: Politecnico di Milano
# Mail:    name.surname@polimi.it
#
#----------------------------------------------------------------------------


import sys
import time
import subprocess
import threading
import os
import re
import math

#Input arguments
design_space_list = sys.argv[1]
soc_folder_suffix = sys.argv[2]
output_folder = sys.argv[3]

board = "xilinx-u55c-xcu55c"
soc_folder = sys.path[0] + "/../../../socs/" + board + "-" + soc_folder_suffix
tcl_script = sys.path[0] + "/automatic_dpr_testing.tcl"

#Serial port connection
serial_port_reading_script = sys.path[0] + "/Serial_Monitor_Configurable.py"
serial_port_name = "USB4"
serial_port_time = 5

if not os.path.exists(output_folder):
  os.makedirs(output_folder)
else:
  print("Output folder already exists. Aborting")
  exit()

destination_folder = output_folder
first_execution_command = "TEST_PROGRAM=./soft-build/ariane/baremetal/generic_tb_rtl.exe make fpga-run"
restart_command = "make fpga-reset"
config_file = soc_folder + "/socgen/esp/.esp_config"

acc_list = []
n_tiles = 0

#This function creates the tcl file and initiate it with the commands to connect to the board
def CreateTcl(outputFile):
  with open(outputFile, "w") as fp:
    fp.write("#THIS SCRIPT HAS BEEN AUTOMATICALLY GENERATED BY " + __file__ + "\n\n")
    fp.write("set target_dev \"null\"\n")
    fp.write("#----Open the hardware manager and connect to the board----\n")
    fp.write("open_hw_manager\n")
    fp.write("connect_hw_server -allow_non_jtag\n")
    fp.write("foreach cable [get_hw_targets ] {\n")
    fp.write("#Temporary modification: digilent cable does not work with profpga\n")
    fp.write("if [string match -nocase *Digilent* $cable] {\n")
    fp.write("continue\n")
    fp.write("}\n")
    fp.write("else {\n")
    fp.write("set target_dev $cable\n")
    fp.write("break }")
    fp.write("open_hw_target $target_dev\n") # {localhost:3121/xilinx_tcf/Xilinx/XFL13CWPGUVRA}\n")
    fp.write("current_hw_device [get_hw_devices xcu280_u55c_0]\n\n")


#This function adds a single partial bitstream to the tcl script
def AddPartialBitstream2Tcl(outputFile, reconfModule, accList, parLvls, tile):
  #First of all, obtain the necessary information from the string
  split_line = reconfModule.split("x")
  acc_name = split_line[0]
  if acc_name != "EMPTY":
    par_lvl = split_line[1] #It's a string!
    #Then, get the position of the accelerator in the list
    acc_id = 0
    for iter_acc in range(0, len(accList)):
      if acc_name in accList[iter_acc]:
        acc_id = iter_acc
        acc_name = accList[acc_id]
        break

  #Finally, open the file and write the tcl code
  with open(outputFile, "a") as fp:
    fp.write("#----Send the partial bitstream for tile " + str(tile) + "----\n")
    fp.write("set_property PROBES.FILE {} [get_hw_devices xcu280_u55c_0]\n")
    fp.write("set_property FULL_PROBES.FILE {} [get_hw_devices xcu280_u55c_0]\n")
    if acc_name == "EMPTY":
      fp.write("set_property PROGRAM.FILE {"+ soc_folder + "/vivado/esp-" + board + ".runs/child_1_impl_1/esp_1_tiles_gen_" + str(tile) + "__dpr_tile_tile_dpr_i_tile_dpr_1_tile_dpr_empty_partial.bit} [get_hw_devices xcu280_u55c_0]\n")
    else:
      fp.write("set_property PROGRAM.FILE {"+ soc_folder + "/vivado/esp-" + board + ".runs/child_" + str(parLvls*acc_id+2+int(math.log2(int(par_lvl)))) + "_impl_1/esp_1_tiles_gen_" + str(tile) + "__dpr_tile_tile_dpr_i_tile_dpr_1_tile_dpr_" + acc_name + "_PAR" + par_lvl + "_partial.bit} [get_hw_devices xcu280_u55c_0]\n")
    fp.write("program_hw_devices [get_hw_devices xcu280_u55c_0]\n\n")


#This function adds the initial full bitstream to the tcl script
def AddFullBitstream2Tcl(outputFile):
  with open(outputFile, "a") as fp:
    fp.write("#----Send the full bitstream ----\n")
    fp.write("set_property PROBES.FILE {} [get_hw_devices xcu280_u55c_0]\n")
    fp.write("set_property FULL_PROBES.FILE {} [get_hw_devices xcu280_u55c_0]\n")
    fp.write("set_property PROGRAM.FILE {"+ soc_folder + "/vivado/esp-" + board + ".runs/child_1_impl_1/top.bit} [get_hw_devices xcu280_u55c_0]\n")
    fp.write("program_hw_devices [get_hw_devices xcu280_u55c_0]\n\n")


#This function scans the configuration space file to find the max parallelism level
# Initialize the maximum number
def GetMaxParLvl(filename):
  max_number = 0
  # Open the file
  with open(filename, 'r') as file:
    # Scan the file line by line
    for line in file:
      # Find all occurrences of 'x' followed by a number
      matches = re.findall(r'x(\d+)', line)
      # Check if any matches were found
      if matches:
        # Convert each found number to an integer and find the max
        max_number = max(max_number, max(map(int, matches)))

  print("The max parallelism level is: ", max_number)
  return max_number


#This function adds the exit command at the end of the tcl script
#(If there's no exit command, everything works but a Vivado process remains active in the background)
def AddExitCommand2Tcl(outputFile):
  with open(outputFile, "a") as fp:
    fp.write("#---- Exit Vivado ----\n")
    fp.write("exit\n")


#Since not all tiles are dpr tiles, this function reads the configuration of the SoC and generates an array that translates the dpr tile number to the SoC tile number
#(e.g. if the SoC is [CPU, IO, DPR0, MEM, DPR1, EMPTY], the array translates 0->2 and 1->4)
def GetTileConversionArray():
  result = []
  tile_count = 0
  with open(config_file, 'r') as file:
    for line_number, line in enumerate(file, start=1):
      if ("TILE_" in line):
        if ("dpr" in line):
          result.append(tile_count)
        tile_count += 1
  return result

#Read the config file and get the number of dpr tiles
def GetNumberOfDprTiles():
  nTiles = 0
  with open(config_file, 'r') as file:
    for line_number, line in enumerate(file, start=1):
      if ("TILE" in line) and ("dpr" in line):
        nTiles += 1
  return nTiles

#Read the config file and get the accelerator list
def GetAccList():
  accList = []
  with open(config_file, 'r') as file:
    for line_number, line in enumerate(file, start=1):
      #List of DPR accelerators
      if "DPR_ACC" in line:
        words = line.split()
        for i in range (2, len(words)):
          accList.append(words[i])
  return accList

def StreamOutput(pipe, stream_type="stdout"):
  """Read and print from the stream in real-time."""
  for line in iter(pipe.readline, b''):
    if stream_type == "stdout":
      print(line.decode().strip())
    elif stream_type == "stderr":
      print(f"Error: {line.decode().strip()}", file=sys.stderr)
  pipe.close()

def LaunchCommand(command):
  #Print the command on the console
  print("\nBash: " + command + "\n")

  # Execute the command and capture both stdout and stderr
  process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

  # Use threading to handle stdout and stderr separately
  stdout_thread = threading.Thread(target=StreamOutput, args=(process.stdout, "stdout"))
  stderr_thread = threading.Thread(target=StreamOutput, args=(process.stderr, "stderr"))

  # Start the threads
  stdout_thread.start()
  stderr_thread.start()

  # Wait for both threads and the process to finish
  stdout_thread.join()
  stderr_thread.join()
  process.wait()

  # If the command failed, print the return code
  if process.returncode != 0:
    print(f"Command failed with return code {process.returncode}")
    exit()


#This function launch a serial monitor that saves the output of the board into a file
def SaveOutput(config, accList):
  outputFile = ""
  for t in range(0, len(config)):
    outputFile += config[t]
    if t < len(config)-1:
      outputFile += "_"

  command = "python3 " + serial_port_reading_script + " " + serial_port_name + " " + destination_folder + "/" + outputFile + ".txt " + str(serial_port_time)
  LaunchCommand(command)


#This function launches vivado executing the tcl script
def LoadBitstream():
  LaunchCommand("vivado -mode batch -source " + tcl_script)




#MAIN PROGRAM
print("\nSTARTING THE DSE\n")


acc_list = GetAccList()
print(acc_list)

n_tiles = GetNumberOfDprTiles()
tile_conversion = GetTileConversionArray()
print(tile_conversion)

n_acc = len(acc_list)

max_par_lvl = GetMaxParLvl(design_space_list)
n_par_lvl = int(math.log2(max_par_lvl)) + 1

#Go to the soc folder
os.chdir(soc_folder)
#Compile the executable
LaunchCommand("make generic_tb_rtl-baremetal")

status = [""]*n_tiles
count = 0
total_testing_time = 0

# Starting the timer
start_time = time.time()

#Generate the tcl script
CreateTcl(tcl_script)
#To start, load the full bitstream and start a first execution (without saving the results)
AddFullBitstream2Tcl(tcl_script)
AddExitCommand2Tcl(tcl_script)
LoadBitstream()
LaunchCommand(first_execution_command)

# Full bitstream loading time
full_bitstream_loading_time = time.time() - start_time
print("\n\n---------------------------------------------------------------------\n\n")
print("Loaded the full bitstream in " + str(full_bitstream_loading_time))
print("\n\n---------------------------------------------------------------------\n\n")

#Then, read the list of configurations and implement each of them
with open(design_space_list, 'r') as file:
  for line_number, line in enumerate(file, start=1):
    # Starting the timer
    config_start_time = time.time()

    #Generate the tcl script
    CreateTcl(tcl_script)

    #Increment the status, starting from the first tile
    status_new = line.split()
    status_new = status_new[:n_tiles]
    for iter_tile in range(0, n_tiles):
    #Add the partial bitstream to the tcl only when it is different from the previous configuration
      if status_new[iter_tile] != status[iter_tile]:
        AddPartialBitstream2Tcl(tcl_script, status_new[iter_tile], acc_list, n_par_lvl, tile_conversion[iter_tile])
    #Overwrite the old status
    status = status_new

    #When all the necessary partial bitstream has been added, start the execution
    AddExitCommand2Tcl(tcl_script)
    LoadBitstream()
    LaunchCommand(restart_command)
    SaveOutput(status, acc_list)
    count += 1

    config_testing_time = time.time() - config_start_time
    total_testing_time += config_testing_time
    average_testing_time = total_testing_time/count
    print("\n\n--------------------------- ITER." + str(count) + " ---------------------------------\n\n")
    print("Full bitstream loading time: " + str(full_bitstream_loading_time))
    print("Current configuration testing time: " + str(config_testing_time))
    print("Average testing time for a configuration: " + str(average_testing_time))
    print("Total DSE time: " + str(time.time() - start_time))
    print("\n\n---------------------------------------------------------------------\n\n")



print("\n\nTOTAL NUMBER OF TESTED CONFIGURATIONS: " + str(count) + "\n")

end = time.time()
print("TOTAL ELAPSED TIME: " + str(end - start) + " seconds\n\n")





