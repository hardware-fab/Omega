// ============================================================================
// Project:   ESP^2 <Temporary Name>
// Authors:   Gabriele Montanaro, Davide Zoni
//
// Description:
//
// An enhanced version of the SoC design tool ESP <Temporary Description>
//
//
// Copyright (c) Politecnico di Milano
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
// ============================================================================
//
// Module: aes256_rtl_basic_dma64
// Description: AES accelerator wrapper with automatically-generated ESP
// accelerator interface.
//
// ============================================================================


//SUFFIXES:
//i: input
//o: output
//n: input of a register (assigned in combinatorial processes, read in sequential processes)
//r: output of a register (read in combinatorial processes, assigned in sequential processes)
//w: wire (used only in combinatorial processes)
//t: type
//cs: current state (read in combinatorial processes, assigned in sequential processes)
//ns: next state (assigned in combinatorial processes, read in sequential processes)
//S: state

//NOTE: this module is partially generated by ESP accgen tool, so not all the code complies
//with the suffix rules described above.

module aes256_rtl_basic_dma64(
  //Vivado HLS ap interface
  input         ap_clk,
  input         ap_rst,
  input         ap_start,
  output reg    ap_done,
  output reg    ap_idle,
  output reg    ap_ready,

  /* <<--params-def-->> */
  input [31:0]  conf_info_aes256_n,
  input [31:0]  conf_info_aes256_keyWords,
  input [31:0]  conf_info_aes256_blockWords,
  input [31:0]  conf_info_aes256_keyReg0,
  input [31:0]  conf_info_aes256_keyReg1,
  input [31:0]  conf_info_aes256_keyReg2,
  input [31:0]  conf_info_aes256_keyReg3,
  input [31:0]  conf_info_aes256_keyReg4,
  input [31:0]  conf_info_aes256_keyReg5,
  input [31:0]  conf_info_aes256_keyReg6,
  input [31:0]  conf_info_aes256_keyReg7,

  input         dma_read_ctrl_ready,
  output reg    dma_read_ctrl_valid,
  output [95:0] dma_read_ctrl_data,

  output        dma_read_chnl_ready,
  input         dma_read_chnl_valid,
  input [63:0]  dma_read_chnl_data,

  input         dma_write_ctrl_ready,
  output reg    dma_write_ctrl_valid,
  output [95:0] dma_write_ctrl_data,

  input         dma_write_chnl_ready,
  output reg    dma_write_chnl_valid,
  output [63:0] dma_write_chnl_data
  );


//////////////////////////////////////////////////////////////////////////////
//    internal wires                                                        //
//////////////////////////////////////////////////////////////////////////////

  reg           acc_start_w;
  reg           acc_rst_w;

  reg    [15:0] cnt_r;
  reg    [15:0] cnt_n;

  reg    [15:0] batch_cnt_r;
  reg    [15:0] batch_cnt_n;

  reg    [31:0] rd_index_r;
  reg    [31:0] rd_index_n;

  reg    [31:0] wr_index_r;
  reg    [31:0] wr_index_n;

  reg           acc_write_chnl_ready_w;
  reg           acc_write_chnl_valid_w;

  reg    [63:0] acc_key_data;
  reg           acc_key_valid;
  reg           acc_key_ready;

  typedef enum logic  [2:0]
  {
    IDLE_S           =  'd0,
    KEY_INIT_S       =  'd1,
    READ_REQ_S       =  'd2,
    READ_DATA_S      =  'd3,
    COMPUTE_S        =  'd4,
    WRITE_REQ_S      =  'd5,
    WRITE_DATA_S     =  'd6
  } state_t;

  state_t fsm_cs, fsm_ns;



//////////////////////////////////////////////////////////////////////////////
//      wire assignments                                                    //
//////////////////////////////////////////////////////////////////////////////

  //Keep ready low, we don't need it
  assign ap_ready                    =   1'b0;

  //Data control read channel
  assign dma_read_ctrl_data[66:64]   =   'd3;
  assign dma_read_ctrl_data[63:32]   =   conf_info_aes256_blockWords;
  assign dma_read_ctrl_data[31:0]    =   rd_index_r;

  //Data control write channel
  assign dma_write_ctrl_data[66:64]   =   'd3;
  assign dma_write_ctrl_data[63:32]   =   conf_info_aes256_blockWords;
  assign dma_write_ctrl_data[31:0]    =   wr_index_r;

//////////////////////////////////////////////////////////////////////////////
//      sequential logic                                                    //
//////////////////////////////////////////////////////////////////////////////

  always @(posedge ap_clk)
  begin
    if (ap_rst)
    begin
      fsm_cs            <=   IDLE_S;
      cnt_r             <=   '0;
      batch_cnt_r       <=   '0;
      rd_index_r        <=   '0;
      wr_index_r        <=   '0;
    end
    else
    begin
      fsm_cs            <=   fsm_ns;
      cnt_r             <=   cnt_n;
      rd_index_r        <=   rd_index_n;
      wr_index_r        <=   wr_index_n;
      batch_cnt_r       <=   batch_cnt_n;
    end
  end

//////////////////////////////////////////////////////////////////////////////
//      combinational logic                                                 //
//////////////////////////////////////////////////////////////////////////////

  always @ (*)
  begin

    //State machine
    fsm_ns                   =   fsm_cs;

    //Registers
    cnt_n                    =   cnt_r;
    batch_cnt_n              =   batch_cnt_r;
    rd_index_n               =   rd_index_r;
    wr_index_n               =   wr_index_r;

    //Wires
    acc_start_w              =   1'b0;
    acc_rst_w                =   1'b0;
    acc_write_chnl_ready_w   =   1'b0;
    acc_key_valid            =   1'b0;
    acc_key_data             =   '0;

    //Outputs
    ap_done                  =   1'b0;
    ap_idle                  =   1'b0;
    dma_read_ctrl_valid      =   1'b0;
    dma_write_ctrl_valid     =   1'b0;
    dma_write_chnl_valid     =   1'b0;

    case (fsm_cs)

      //IDLE: accelerator is waiting to start operation
      IDLE_S:
      begin
        ap_idle        =   1'b1;
        //Index counters need to be initialized
        rd_index_n     =   'd0;
        wr_index_n     =   conf_info_aes256_blockWords[15:0]*conf_info_aes256_n[15:0];

        // Start accelerator
        if (ap_start)
        begin
          //Reset the module after each operation
          acc_rst_w    =   1'b1;
          //Start with the key initialization (to be done once for each batch)
          fsm_ns       =   KEY_INIT_S;
        end
      end

      //KEY INIT: send the key to the AES for key initialization
      KEY_INIT_S:
      begin
        acc_key_valid                 =   1'b1;
        if(cnt_r == 0)
          acc_key_data                =   {conf_info_aes256_keyReg1, conf_info_aes256_keyReg0};
        else if(cnt_r == 1)
          acc_key_data                =   {conf_info_aes256_keyReg3, conf_info_aes256_keyReg2};
        else if(cnt_r == 2)
          acc_key_data                =   {conf_info_aes256_keyReg5, conf_info_aes256_keyReg4};
        else
          acc_key_data                =   {conf_info_aes256_keyReg7, conf_info_aes256_keyReg6};
        if(acc_key_ready)
        begin
          cnt_n                       =   cnt_r + 1;
          if(cnt_r == conf_info_aes256_keyWords-1)
          begin
            cnt_n                     =   '0;
            fsm_ns                    =   READ_REQ_S;
          end
        end
      end

      //READ REQUEST: the accelerator requests data from the memory
      READ_REQ_S:
      begin
        dma_read_ctrl_valid           =   1'b1;
        if(dma_read_ctrl_ready)
        begin
          fsm_ns                      =   READ_DATA_S;
          rd_index_n                  =   rd_index_r + conf_info_aes256_blockWords;
        end
      end

      //READ DATA: read the data coming from the memory
      READ_DATA_S:
      begin
        //The data port is connected directly with the internal AXI-Stream accelerator.
        //This wrapper only needs to monitor the number of exchanged words to start
        //the computation when the communication is done.
        if(dma_read_chnl_ready && dma_read_chnl_valid)
        begin
          cnt_n                       =   cnt_r + 1;
          if(cnt_r == conf_info_aes256_blockWords-1)
          begin
            fsm_ns                    =   COMPUTE_S;
            cnt_n                     =   'd0;
          end
        end
      end

      //COMPUTE: compute state
      COMPUTE_S:
      begin
        //Wait for the internal computation to end
        if (acc_write_chnl_valid_w)
        begin
          fsm_ns                      =   WRITE_REQ_S;
        end
      end

      //WRITE REQUEST: the accelerator requests to write data to memory
      WRITE_REQ_S:
      begin
        dma_write_ctrl_valid          =   1'b1;
        if(dma_write_ctrl_ready)
        begin
          fsm_ns                      =   WRITE_DATA_S;
          //ap_done                     =   1'b1;
          wr_index_n                  =   wr_index_r + conf_info_aes256_blockWords;
        end
      end

      //WRITE DATA: write the output to the memory
      WRITE_DATA_S:
      begin
        //The data port is connected directly with the internal AXI-Stream accelerator.
        //This wrapper only needs to monitor the number of exchanged words to end
        //the execution when the communication is done.
        acc_write_chnl_ready_w        =   dma_write_chnl_ready;
        dma_write_chnl_valid          =   acc_write_chnl_valid_w;
        if(dma_write_chnl_ready && dma_write_chnl_valid)
        begin
          cnt_n                       =   cnt_r + 1;
          if(cnt_r == conf_info_aes256_blockWords-1)
          begin
            cnt_n                     =   'd0;
            //If the number of total batches has been reached, ends the execution.
            //If not, starts automatically another operation.
            if(batch_cnt_r == conf_info_aes256_n-1)
            begin
              ap_done                 =   1'b1;
              fsm_ns                  =   IDLE_S;
              batch_cnt_n             =   '0;
            end
            else
            begin
              fsm_ns                  =   READ_REQ_S;
              batch_cnt_n             =   batch_cnt_r + 1;
            end
          end
        end
      end

      default:
      begin
        fsm_ns                        =   IDLE_S;
      end
    endcase
  end

//////////////////////////////////////////////////////////////////////////////
//    internal submodules                                                   //
//////////////////////////////////////////////////////////////////////////////

  aes_axis_wrapper aes_inst
  (
    .clk_i              (ap_clk),
    .rst_i              (acc_rst_w),

    .rd_key_data_i      (acc_key_data),
    .rd_key_valid_i     (acc_key_valid),
    .rd_key_ready_o     (acc_key_ready),

    .rd_block_data_i    (dma_read_chnl_data),
    .rd_block_valid_i   (dma_read_chnl_valid),
    .rd_block_ready_o   (dma_read_chnl_ready),

    .wr_data_o          (dma_write_chnl_data),
    .wr_valid_o         (acc_write_chnl_valid_w),
    .wr_ready_i         (acc_write_chnl_ready_w)
  );


endmodule
