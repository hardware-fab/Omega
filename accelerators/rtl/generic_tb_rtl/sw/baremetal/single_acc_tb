/* Copyright (c) 2011-2023 Columbia University, System Level Design Group */
/* SPDX-License-Identifier: Apache-2.0 */

#include <stdio.h>
#ifndef __riscv
#include <stdlib.h>
#endif

#include "esp_accelerator.h"
#include "esp_probe.h"
#include "fixed_point.h"

#include "accelerators.h"
#include <monitors.h>

//---------------------Timer Definitions-----------------------------
#define BASE_ADDRESS 0x60000300
#define TIMER_LO 0xB4
#define TIMER_HI 0xB8
#define DOMAIN_0 ((16 + 0)*4 + 128)
#define DOMAIN_1 ((16 + 1)*4 + 128)
#define DOMAIN_2 ((16 + 2)*4 + 128)
#define DOMAIN_3 ((16 + 3)*4 + 128)
#define DOMAIN_4 ((16 + 4)*4 + 128)

static long unsigned custom_gettime_nano()
{
	volatile unsigned long timer_reg_lo, timer_reg_hi;
	volatile uint32_t * timer_lo_ptr = (volatile uint32_t *)(BASE_ADDRESS + TIMER_LO);
	volatile uint32_t * timer_hi_ptr = (volatile uint32_t *)(BASE_ADDRESS + TIMER_HI);
	timer_reg_lo = *timer_lo_ptr;
	timer_reg_hi = *timer_hi_ptr;
	return (long unsigned) ((*timer_lo_ptr | (long unsigned)(*timer_hi_ptr)<<32)*CLOCK_PERIOD);
}

static void print_time(long unsigned value)
{
	uint32_t nano = value%1000;
	uint32_t micro = (value%1000000)/1000;
	uint32_t milli = (value%1000000000)/1000000;
	uint32_t sec = (value%1000000000000)/1000000000;
	printf("Original Value = %lu : %u s - %u ms - %u us - %u ns", value, sec, milli, micro, nano);
}

static void print_time_us(long unsigned value)
{
	uint32_t decimal = value%1000;
	uint32_t integer = (value)/1000;
	printf("%u,%03u", integer, decimal);
}

static void wait_micro(long unsigned waiting_time)
{
	long unsigned start, end;
	start = custom_gettime_nano();
	end = 0;
	while(end < start + waiting_time*1000)
		end = custom_gettime_nano();
	return;
}

//--------------Global Variables--------------------------
//Accelerators size variables
static unsigned in_words_adj[N_ACC_TILES];
static unsigned out_words_adj[N_ACC_TILES];
static unsigned in_len[N_ACC_TILES];
static unsigned out_len[N_ACC_TILES];
static unsigned in_size[N_ACC_TILES];
static unsigned out_size[N_ACC_TILES];
static unsigned out_offset[N_ACC_TILES];
static unsigned mem_size[N_ACC_TILES];

//Devices info
struct esp_device *acc_ptr[N_ACC_TILES];

//Accelerators I/O
unsigned **ptable[N_ACC_TILES];
uint8_t *mem[N_ACC_TILES];
uint8_t *gold[N_ACC_TILES];
unsigned errors = 0;

//Execution results
unsigned samples_counter = 0;
//unsigned packets_data[N_SAMPLES];
//unsigned packets_data_2[N_SAMPLES];
//uint8_t noc_frequency_data[N_SAMPLES];
//uint8_t acc_frequency_data[N_SAMPLES];
//uint8_t tg_frequency_data[N_SAMPLES];
//unsigned time_data_debug[N_SAMPLES];

//Accelerators batch sizes
unsigned acc_batch_sizes[N_ACC_TILES];


//--------------Functions Declaration------------------
int init_devs();
void config_cache();
void run_acc();

int main(int argc, char * argv[])
{
	printf("------------------------------------------------------------------------------------------------------\n--------------------------------------------------------------------------------------------------------------------------------------\n--------------------------------------------------------------------------------------------------------------------------------------\n--------------------------------------------------------------------------------------------------------------------------------------\n-----------------------------------------------------------START-----------------------------------------------------------------------------------------------------------------------------------\n--------------------------------------------------------------------------------------------------------------------------------------\n--------------------------------------------------------------------------------------------------------------------------------------\n---------------------------------------------------------------------------------------------\n\n\n");

	//-----------------------------------Local variables------------------------------------

	//Accelerators execution
	int ready = 0;
	int counter = 0;
	unsigned done = 0;

	//Time variables
	double start_time, time_elapsed = 0;
	double time_acc = 0;
	double window_start, window_end;
	unsigned long window_actual_time;

	//Frequency data
	unsigned noc_freq = 1;
	volatile uint32_t * noc_freq_reg = (volatile uint32_t *)(BASE_ADDRESS + DOMAIN_0);
	volatile uint32_t * cpu_freq_reg = (volatile uint32_t *)(BASE_ADDRESS + DOMAIN_1);
    volatile uint32_t * acc_freq_reg = (volatile uint32_t *)(BASE_ADDRESS + DOMAIN_2);
	uint8_t noc_freq_int = 0;
	uint8_t cpu_freq_int = 0;
	uint8_t acc_freq_int = 0;

	int dfadd_active = 0;

	init_devs();
	printf("The devices have been initialized\n");
    cpu_freq_int = 9;
	acc_freq_int = 9;
	noc_freq_int = 19;
	*cpu_freq_reg = cpu_freq_int;
	*acc_freq_reg = acc_freq_int;
	*noc_freq_reg = noc_freq_int;

	start_time = custom_gettime_nano();

	run_acc(0);
	//printf("Checkpoint 5\n");
	while(!(ready && time_elapsed))
	{
		//-------------------ACCELERATORS EXECUTION----------------------------

		done = ioread32(acc_ptr[0], STATUS_REG);
		//printf("\nDone %d", done);
		done &= STATUS_MASK_DONE;
		if(!ready && done)
		{
			done = 0;
			iowrite32(acc_ptr[0], CMD_REG, 0x0);
			run_acc(0);
			counter++;
			if(time_elapsed)
			{
				time_acc = custom_gettime_nano() - start_time;
				ready = 1;
			}
		}

		if(custom_gettime_nano() - start_time > ((unsigned long)MAX_TEST_TIME*1000000000) && !time_elapsed)
			time_elapsed = 1;

	}

	printf("\nTempo di esecuzione: ");

	print_time_us(time_acc/(counter*acc_batch_sizes[0]));
	printf("\n");

    printf("Execution Completed\n");

	for(int ndev=0; ndev = N_ACC_TILES; ndev++)
	{
		aligned_free(ptable[ndev]);
		aligned_free(mem[ndev]);
		aligned_free(gold[ndev]);
	}
	return 0;
}


//---------------Initialization of the devices----------------
int init_devs()
{
	int ndev = 0;
	struct esp_device *espdevs;
	// Search for the device
	printf("Scanning device tree... \n");
    for(int i = 0; i<N_ACC_TYPES; i++)
	//for(int i = N_ACC_TYPES - 1; i>= 0; i--)
	{
		//For every loop, search for a different accelerator type
		int ndev_local = 0;
		if (i==0)
		{
			ndev_local = probe(&espdevs, VENDOR_SLD, SLD_ADPCM, DEV_NAME_ADPCM);
			if (ndev_local == 0)
				printf("adpcm not found\n");
		}
        else if(i == 1)
		{
			ndev_local = probe(&espdevs, VENDOR_SLD, SLD_AES, DEV_NAME_AES);
			if (ndev_local == 0)
				printf("aes not found\n");
		}
		 else if(i == 2)
		{
			ndev_local = probe(&espdevs, VENDOR_SLD, SLD_BLOWFISH, DEV_NAME_BLOWFISH);
			if (ndev_local == 0)
				printf("blowfish not found\n");
		}
		 else if(i == 3)
		{
			ndev_local = probe(&espdevs, VENDOR_SLD, SLD_DFADD, DEV_NAME_DFADD);
			if (ndev_local == 0)
				printf("dfadd not found\n");
		}
		 else if(i == 4)
		{
			ndev_local = probe(&espdevs, VENDOR_SLD, SLD_DFDIV, DEV_NAME_DFDIV);
			if (ndev_local == 0)
				printf("dfdiv not found\n");
		}
		 else if(i == 5)
		{
			ndev_local = probe(&espdevs, VENDOR_SLD, SLD_DFMUL, DEV_NAME_DFMUL);
			if (ndev_local == 0)
				printf("dfmul not found\n");
		}
		 else if(i == 6)
		{
			ndev_local = probe(&espdevs, VENDOR_SLD, SLD_DFSIN, DEV_NAME_DFSIN);
			if (ndev_local == 0)
				printf("dfsin not found\n");
		}
		 else if(i == 7)
		{
			ndev_local = probe(&espdevs, VENDOR_SLD, SLD_GSM, DEV_NAME_GSM);
			if (ndev_local == 0)
				printf("gsm not found\n");
		}
		 else if(i == 8)
		{
			ndev_local = probe(&espdevs, VENDOR_SLD, SLD_MIPS, DEV_NAME_MIPS);
			if (ndev_local == 0)
				printf("mips not found\n");
		}
		 else if(i == 9)
		{
			ndev_local = probe(&espdevs, VENDOR_SLD, SLD_MOTION, DEV_NAME_MOTION);
			if (ndev_local == 0)
				printf("motion not found\n");
		}
		 else if(i == 10)
		{
			ndev_local = probe(&espdevs, VENDOR_SLD, SLD_SHA, DEV_NAME_SHA);
			if (ndev_local == 0)
				printf("sha not found\n");
		}
		for (int n = 0; n < ndev_local; n++) {
            //For each accelerator of a given type, initialize all the variables
			//printf("**************** %s.%d ****************\n", espdevs[n].name, n);

			acc_ptr[ndev] = &espdevs[n];

			printf("\nDEVICE INFO\n\n");
			printf("Vendor: %x\n", acc_ptr[ndev]->vendor);
			printf("ID: %x\n", acc_ptr[ndev]->id);
			printf("Number: %x\n", acc_ptr[ndev]->number);
			printf("IRQ: %x\n", acc_ptr[ndev]->irq);
			printf("Address: %llx\n", acc_ptr[ndev]->addr);
			printf("Compat: %u\n", acc_ptr[ndev]->compat);
			printf("Name: %s\n", acc_ptr[ndev]->name);

			printf("PT NCHUNK MAX REG: %d\n", ioread32(acc_ptr[ndev], PT_NCHUNK_MAX_REG));

			//Collect the sizes of its IO
			//printf("Checkpoint 1\n");
			init_size_all(&in_words_adj[ndev], &out_words_adj[ndev], &in_len[ndev], &out_len[ndev], &in_size[ndev], &out_size[ndev], &out_offset[ndev], &mem_size[ndev], i);
			get_batch_size(&acc_batch_sizes[ndev], i);

			// Check DMA capabilities
			if (ioread32(acc_ptr[ndev], PT_NCHUNK_MAX_REG) == 0)
			{
				printf("  -> scatter-gather DMA is disabled. Abort.\n");
				//continue;
			}

			//printf("Checkpoint 2\n");

			if (ioread32(acc_ptr[ndev], PT_NCHUNK_MAX_REG) < NCHUNK(mem_size[ndev])) {
				printf("  -> Not enough TLB entries available. Abort.\n");
				//continue;
			}

			//printf("Checkpoint 3\n");

			// Allocate memory
			gold[ndev] = aligned_malloc(out_size[ndev]);
			mem[ndev] = aligned_malloc(mem_size[ndev]);
			//printf("out_size = %d, mem_size=%d\n", out_size[ndev], mem_size[ndev]);
			//printf("  memory buffer base-address = %p\n", mem[ndev]);

			// Alocate and populate page table
			ptable[ndev] = aligned_malloc(NCHUNK(mem_size[ndev]) * sizeof(unsigned *));
			for (int j = 0; j < NCHUNK(mem_size[ndev]); j++)
				ptable[ndev][j] = (unsigned *) &mem[ndev][j * (CHUNK_SIZE / sizeof_token[i])];

			//printf("  ptable = %p\n", ptable[ndev]);
			//printf("  nchunk = %lu\n", NCHUNK(mem_size[ndev]));

			config_cache(ndev, i);

			ndev += 1;
		}
	}
}



//---------------Cache configuration functions----------------
void config_cache(int ndev, int acc_type)
{
	unsigned coherence;
	/* TODO: Restore full test once ESP caches are integrated */
	coherence = ACC_COH_NONE;
	printf("  --------------------\n");
	printf("  Generate input for acc %d of type %d...\n", ndev, acc_type);
	init_buf_all(mem[ndev], gold[ndev], in_words_adj[ndev], acc_type);
    //printf("Checkpoint1 - overcame init_buf_all\n");
	// Pass common configuration parameters

	iowrite32(acc_ptr[ndev], SELECT_REG, ioread32(acc_ptr[ndev], DEVID_REG));
	iowrite32(acc_ptr[ndev], COHERENCE_REG, coherence);
    //printf("Checkpoint2\n");
#ifndef __sparc
	iowrite32(acc_ptr[ndev], PT_ADDRESS_REG, (unsigned long long) ptable[ndev]);
#else
	iowrite32(acc_ptr[ndev], PT_ADDRESS_REG, (unsigned) ptable[ndev]);
#endif
	iowrite32(acc_ptr[ndev], PT_NCHUNK_REG, NCHUNK(mem_size[ndev]));
	iowrite32(acc_ptr[ndev], PT_SHIFT_REG, CHUNK_SHIFT);
    //printf("Checkpoint3\n");
	// Use the following if input and output data are not allocated at the default offsets
	iowrite32(acc_ptr[ndev], SRC_OFFSET_REG, 0x0);
	iowrite32(acc_ptr[ndev], DST_OFFSET_REG, 0x0);
    //printf("Checkpoint4\n");
	// Pass accelerator-specific configuration parameters
	/* <<--regs-config-->> */
	config_acc_param(acc_ptr[ndev], acc_type);
    //printf("Checkpoint8 - overcame config_acc_param\n");
	// Flush (customize coherence model here)
	esp_flush(coherence);
	//printf("Checkpoint9 - overcame esp_flush\n");
}

//------------------Starting Functions
void run_acc(int ndev)
{
	// Start accelerators
	//printf("  Start...\n");
	iowrite32(acc_ptr[ndev], CMD_REG, CMD_MASK_START);
}
