/* Copyright (c) 2011-2023 Columbia University, System Level Design Group */
/* SPDX-License-Identifier: Apache-2.0 */

#include <stdio.h>
#ifndef __riscv
#include <stdlib.h>
#endif

#include "esp_accelerator.h"
#include "esp_probe.h"
#include "fixed_point.h"

#include "accelerators.h"
#include <monitors.h>

//---------------------TEST CONFIGURATION----------------------------
#define N_TESTS (N_ACC_TILES-2+1) //NUMBER OF TRAFFIC GENERATORS + 1

//---------------------Timer Definitions-----------------------------
#define BASE_ADDRESS 0x60000300
#define TIMER_LO 0xB4
#define TIMER_HI 0xB8
#define DOMAIN_0 ((16 + 0)*4 + 128)
#define DOMAIN_1 ((16 + 1)*4 + 128)
#define DOMAIN_2 ((16 + 2)*4 + 128)
#define DOMAIN_3 ((16 + 3)*4 + 128)
#define DOMAIN_4 ((16 + 4)*4 + 128)

static long unsigned custom_gettime_nano()
{
    volatile unsigned long timer_reg_lo, timer_reg_hi;
    volatile uint32_t * timer_lo_ptr = (volatile uint32_t *)(BASE_ADDRESS + TIMER_LO);
    volatile uint32_t * timer_hi_ptr = (volatile uint32_t *)(BASE_ADDRESS + TIMER_HI);
    timer_reg_lo = *timer_lo_ptr;
    timer_reg_hi = *timer_hi_ptr;
    return (long unsigned) ((*timer_lo_ptr | (long unsigned)(*timer_hi_ptr)<<32)*CLOCK_PERIOD);
}

static void print_time(long unsigned value)
{
    uint32_t nano = value%1000;
    uint32_t micro = (value%1000000)/1000;
    uint32_t milli = (value%1000000000)/1000000;
    uint32_t sec = (value%1000000000000)/1000000000;
    printf("Original Value = %lu : %u s - %u ms - %u us - %u ns", value, sec, milli, micro, nano);
}

static void print_time_us(long unsigned value)
{
    uint32_t decimal = value%1000;
    uint32_t integer = (value)/1000;
    printf("%u,%03u", integer, decimal);
}

static void wait_micro(long unsigned waiting_time)
{
    long unsigned start, end;
    start = custom_gettime_nano();
    end = 0;
    while(end < start + waiting_time*1000)
        end = custom_gettime_nano();
    return;
}

static void print_float(float var)
{
    uint32_t var_int = (uint32_t)(var*1000);
    uint32_t integer = var_int / 1000;
    uint32_t decimal = var_int % 1000;
    printf("%u,%03u", integer, decimal);
}

//--------------Global Variables--------------------------
//Accelerators size variables
static unsigned in_words_adj[N_ACC_TILES];
static unsigned out_words_adj[N_ACC_TILES];
static unsigned in_len[N_ACC_TILES];
static unsigned out_len[N_ACC_TILES];
static unsigned in_size[N_ACC_TILES];
static unsigned out_size[N_ACC_TILES];
static unsigned out_offset[N_ACC_TILES];
static unsigned mem_size[N_ACC_TILES];

//Devices info
struct esp_device *acc_ptr[N_ACC_TILES];

//Accelerators I/O
unsigned **ptable[N_ACC_TILES];
uint8_t *mem[N_ACC_TILES];
uint8_t *gold[N_ACC_TILES];
unsigned errors = 0;

//Execution results
unsigned samples_counter = 0;
//unsigned packets_data[N_SAMPLES];
//unsigned packets_data_2[N_SAMPLES];
//uint8_t noc_frequency_data[N_SAMPLES];
//uint8_t acc_frequency_data[N_SAMPLES];
//uint8_t tg_frequency_data[N_SAMPLES];
//unsigned time_data_debug[N_SAMPLES];

//Accelerators batch sizes
unsigned acc_batch_sizes[N_ACC_TILES];

int acc_a1 = -1, acc_a2 = -1;
int inactive_acc = 0;

//Order of activation of TG
uint8_t tg_activation_order[N_ACC_TILES-2] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};  //tile order
//uint8_t tg_activation_order[N_ACC_TILES-2] = {4, 8, 9, 10, 0, 1, 5, 6, 2, 3, 7};  //XY order
//uint8_t tg_activation_order[N_ACC_TILES-2] = {7, 3, 2, 6, 5, 1, 0, 10, 9, 8, 4};  //Inverted XY order

//--------------Functions Declaration------------------
int init_devs();
void config_cache();
void run_acc();

int main(int argc, char * argv[])
{
    printf("------------------------------------------------------------------------------------------------------\n--------------------------------------------------------------------------------------------------------------------------------------\n--------------------------------------------------------------------------------------------------------------------------------------\n--------------------------------------------------------------------------------------------------------------------------------------\n-----------------------------------------------------------START-----------------------------------------------------------------------------------------------------------------------------------\n--------------------------------------------------------------------------------------------------------------------------------------\n--------------------------------------------------------------------------------------------------------------------------------------\n---------------------------------------------------------------------------------------------\n\n\n");

    //-----------------------------------Local variables------------------------------------

    //Accelerators execution
    int ready[N_ACC_TILES] = {0};
    int counter = 0;
    unsigned done[N_ACC_TILES] = {0};
    unsigned ready_all = 0;

    //Time variables
    double start_time, time_elapsed = 0;
    double time_acc = 0;
    double window_start, window_end;
    unsigned long window_actual_time;

    //Frequency data
    unsigned noc_freq = 1;
    volatile uint32_t * noc_freq_reg = (volatile uint32_t *)(BASE_ADDRESS + DOMAIN_0);
    volatile uint32_t * cpu_freq_reg = (volatile uint32_t *)(BASE_ADDRESS + DOMAIN_1);
    volatile uint32_t * acc_freq_reg = (volatile uint32_t *)(BASE_ADDRESS + DOMAIN_2);
    volatile uint32_t * tg_freq_reg = (volatile uint32_t *)(BASE_ADDRESS + DOMAIN_3);
    uint8_t noc_freq_int = 0;
    uint8_t cpu_freq_int = 0;
    uint8_t acc_freq_int = 0;
    uint8_t tg_freq_int = 0;

    int tg_active = 0;
    int active_acc = 0;
    int inactive_acc = 0;
    int tg_count = 0;
    float roundtrip_time = 0.0;

    init_devs();
    //The target accelerators are DFADD as well: identify them based on their positions
    if(acc_a1 == -1)
    {
        acc_a1 = 2;
        acc_a2 = N_ACC_TILES-1;
    }
    printf("The position in the list of accelerator A1 is: %d\n", acc_a1);
    printf("The position in the list of accelerator A2 is: %d\n", acc_a2);
    printf("The devices have been initialized\n");
    cpu_freq_int = 9;
    acc_freq_int = 9;
    noc_freq_int = 1;
    tg_freq_int = 9;
    *cpu_freq_reg = cpu_freq_int;
    *acc_freq_reg = acc_freq_int;
    *noc_freq_reg = noc_freq_int;
    *tg_freq_reg = tg_freq_int;
    //printf("Checkpoint 1\n");
    for (int m=0; m<N_TESTS; m++)
    {
        //Choose the active accelerator
        active_acc = acc_a2;
        inactive_acc = acc_a1;
        //printf("Active accelerator: %d\nInactive accelerator: %d\n", active_acc, inactive_acc);
        //printf("Checkpoint 4\n");
        //Reset the control variables
        roundtrip_time = 0.0;
        ready_all = 0;
        counter = 0;
        time_elapsed = 0;
        //If the accelerator should be disabled, set it as ready
        tg_count = 0;
        for(int ndev=0; ndev<N_ACC_TILES; ndev++)
        {
            //If the accelerator is the inactive one, set it ready
            if(ndev == inactive_acc)
                ready[ndev] = 1;
            //if the accelerator is the active one, set it not ready
            else if(ndev == active_acc)
                ready[ndev] = 0;
            //If the accelerator is a tg, verify if it should be activated
            else
                if(tg_count<m)
                {
                    ready[tg_activation_order[ndev-2]+2] = 0; //This works if the DUT name cames after DFADD!
                    tg_count++;
                }
                else
                {
                    ready[tg_activation_order[ndev-2]+2] = 1; //This works if the DUT name cames after DFADD!
                    tg_count++;
                }
            done[ndev] = 0;
        }
        //printf("Checkpoint 5\n");
        //Start the traffic generators
        tg_count = 0;
        for(int ndev=0; ndev<N_ACC_TILES; ndev++)
        {
            if(ndev != active_acc && ndev != inactive_acc)
                if(tg_count<m)
                {
                    run_acc(tg_activation_order[ndev-2]+2);  //This works if the DUT name cames after DFADD!
                    tg_count++;
                }
                else
                    break;
        }
        //printf("Checkpoint 6\n");
        //Start the timer
        start_time = custom_gettime_nano();

        //Start the accelerator under test
        run_acc(active_acc);

        //printf("Checkpoint 7\n");
        //printf("Checkpoint 5\n");
        while(!(ready_all && time_elapsed))
        {
            //-------------------ACCELERATORS EXECUTION----------------------------
            //printf("Checkpoint 8\n");
            ready_all = 1;
            for(int ndev=0; ndev<N_ACC_TILES; ndev++)
            {
                if(!ready[ndev])
                {
                    ready_all = 0;
                    //Check done
                    done[ndev] = ioread32(acc_ptr[ndev], STATUS_REG);
                    done[ndev] &= STATUS_MASK_DONE;
                    if(done[ndev])
                    {
                        //printf("Acc%d is done\n", ndev);
                        //Restart the accelerator
                        done[ndev] = 0;
                        iowrite32(acc_ptr[ndev], CMD_REG, 0x0);
                        run_acc(ndev);
                        //If the accelerator is the one under test, collect the execution statistics
                        if(ndev == active_acc)
                        {
                            roundtrip_time = roundtrip_time + (float) esp_monitor_rtt_1tile(15);  //ACTIVE ACCELERATOR POSITION FIXED TO 15
                            counter++;
                            if(time_elapsed)
                            {
                                time_acc = custom_gettime_nano() - start_time;
                                ready[ndev] = 1;
                            }
                        }
                        else
                        {
                            if(time_elapsed)
                                ready[ndev] = 1;
                        }
                    }
                }
            }
            if(custom_gettime_nano() - start_time > ((unsigned long)MAX_TEST_TIME*1000000000) && !time_elapsed)
                time_elapsed = 1;
        }

        roundtrip_time = roundtrip_time/((acc_freq_int+1)*5*counter);
        printf("Tempo di esecuzione di %s: %d - ", acc_ptr[active_acc]->name, m);
        print_float(roundtrip_time);
        printf(" - ");
        print_time_us(time_acc/(counter*acc_batch_sizes[active_acc]));
        printf("\n");
    }
    printf("Execution Completed\n");

    for(int ndev=0; ndev = N_ACC_TILES; ndev++)
    {
        aligned_free(ptable[ndev]);
        aligned_free(mem[ndev]);
        aligned_free(gold[ndev]);
    }
    return 0;
}


//---------------Initialization of the devices----------------
int init_devs()
{
    int ndev = 0;
    struct esp_device *espdevs;
    // Search for the device
    printf("Scanning device tree... \n");
    for(int i = 0; i<N_ACC_TYPES; i++)
    //for(int i = N_ACC_TYPES - 1; i>= 0; i--)
    {
        //For every loop, search for a different accelerator type
        int ndev_local = 0;
        if (i==0)
        {
            ndev_local = probe(&espdevs, VENDOR_SLD, SLD_ADPCM, DEV_NAME_ADPCM);
            if (ndev_local == 0)
                printf("adpcm not found\n");
        }
        else if(i == 1)
        {
            ndev_local = probe(&espdevs, VENDOR_SLD, SLD_AES, DEV_NAME_AES);
            if (ndev_local == 0)
                printf("aes not found\n");
        }
        else if(i == 2)
        {
            ndev_local = probe(&espdevs, VENDOR_SLD, SLD_BLOWFISH, DEV_NAME_BLOWFISH);
            if (ndev_local == 0)
                printf("blowfish not found\n");
        }
        else if(i == 3)
        {
            ndev_local = probe(&espdevs, VENDOR_SLD, SLD_DFADD, DEV_NAME_DFADD);
            if (ndev_local == 0)
                printf("dfadd not found\n");
        }
        else if(i == 4)
        {
            ndev_local = probe(&espdevs, VENDOR_SLD, SLD_DFDIV, DEV_NAME_DFDIV);
            if (ndev_local == 0)
                printf("dfdiv not found\n");
        }
        else if(i == 5)
        {
            ndev_local = probe(&espdevs, VENDOR_SLD, SLD_DFMUL, DEV_NAME_DFMUL);
            if (ndev_local == 0)
                printf("dfmul not found\n");
        }
        else if(i == 6)
        {
            ndev_local = probe(&espdevs, VENDOR_SLD, SLD_DFSIN, DEV_NAME_DFSIN);
            if (ndev_local == 0)
                printf("dfsin not found\n");
        }
        else if(i == 7)
        {
            ndev_local = probe(&espdevs, VENDOR_SLD, SLD_GSM, DEV_NAME_GSM);
            if (ndev_local == 0)
                printf("gsm not found\n");
        }
        else if(i == 8)
        {
            ndev_local = probe(&espdevs, VENDOR_SLD, SLD_MIPS, DEV_NAME_MIPS);
            if (ndev_local == 0)
                printf("mips not found\n");
        }
        else if(i == 9)
        {
            ndev_local = probe(&espdevs, VENDOR_SLD, SLD_MOTION, DEV_NAME_MOTION);
            if (ndev_local == 0)
                printf("motion not found\n");
        }
        else if(i == 10)
        {
            ndev_local = probe(&espdevs, VENDOR_SLD, SLD_SHA, DEV_NAME_SHA);
            if (ndev_local == 0)
                printf("sha not found\n");
        }
        for (int n = 0; n < ndev_local; n++) {
            //For each accelerator of a given type, initialize all the variables
            //printf("**************** %s.%d ****************\n", espdevs[n].name, n);

            acc_ptr[ndev] = &espdevs[n];

            printf("\nDEVICE INFO\n\n");
            printf("Vendor: %x\n", acc_ptr[ndev]->vendor);
            printf("ID: %x\n", acc_ptr[ndev]->id);
            printf("Number: %x\n", acc_ptr[ndev]->number);
            printf("IRQ: %x\n", acc_ptr[ndev]->irq);
            printf("Address: %llx\n", acc_ptr[ndev]->addr);
            printf("Compat: %u\n", acc_ptr[ndev]->compat);
            printf("Name: %s\n", acc_ptr[ndev]->name);

            printf("PT NCHUNK MAX REG: %d\n", ioread32(acc_ptr[ndev], PT_NCHUNK_MAX_REG));

            //Collect the sizes of its IO
            //printf("Checkpoint 1\n");
            init_size_all(&in_words_adj[ndev], &out_words_adj[ndev], &in_len[ndev], &out_len[ndev], &in_size[ndev], &out_size[ndev], &out_offset[ndev], &mem_size[ndev], i);
            get_batch_size(&acc_batch_sizes[ndev], i);

            //SPECIFIC PART FOR FCCM EXPERIMENTS
            //If the accelerator is not a DFADD, save its position
            printf("\n\ni=%d, ndev=%d\n", i, ndev);
            if(i!=3)
            {
                if(acc_a1 == -1)
                    acc_a1 = ndev;
                else
                    acc_a2 = ndev;
                printf("a1=%d, a2=%d\n", acc_a1, acc_a2);

            }
            // Check DMA capabilities
            if (ioread32(acc_ptr[ndev], PT_NCHUNK_MAX_REG) == 0)
            {
                printf("  -> scatter-gather DMA is disabled. Abort.\n");
                //continue;
            }

            //printf("Checkpoint 2\n");

            if (ioread32(acc_ptr[ndev], PT_NCHUNK_MAX_REG) < NCHUNK(mem_size[ndev])) {
                printf("  -> Not enough TLB entries available. Abort.\n");
                //continue;
            }

            //printf("Checkpoint 3\n");

            // Allocate memory
            gold[ndev] = aligned_malloc(out_size[ndev]);
            mem[ndev] = aligned_malloc(mem_size[ndev]);
            //printf("out_size = %d, mem_size=%d\n", out_size[ndev], mem_size[ndev]);
            //printf("  memory buffer base-address = %p\n", mem[ndev]);

            // Alocate and populate page table
            ptable[ndev] = aligned_malloc(NCHUNK(mem_size[ndev]) * sizeof(unsigned *));
            for (int j = 0; j < NCHUNK(mem_size[ndev]); j++)
                ptable[ndev][j] = (unsigned *) &mem[ndev][j * (CHUNK_SIZE / sizeof_token[i])];

            //printf("  ptable = %p\n", ptable[ndev]);
            //printf("  nchunk = %lu\n", NCHUNK(mem_size[ndev]));

            config_cache(ndev, i);

            ndev += 1;
        }
    }
}



//---------------Cache configuration functions----------------
void config_cache(int ndev, int acc_type)
{
    unsigned coherence;
    /* TODO: Restore full test once ESP caches are integrated */
    coherence = ACC_COH_NONE;
    printf("  --------------------\n");
    printf("  Generate input for acc %d of type %d...\n", ndev, acc_type);
    init_buf_all(mem[ndev], gold[ndev], in_words_adj[ndev], acc_type);
    //printf("Checkpoint1 - overcame init_buf_all\n");
    // Pass common configuration parameters

    iowrite32(acc_ptr[ndev], SELECT_REG, ioread32(acc_ptr[ndev], DEVID_REG));
    iowrite32(acc_ptr[ndev], COHERENCE_REG, coherence);
    //printf("Checkpoint2\n");
#ifndef __sparc
    iowrite32(acc_ptr[ndev], PT_ADDRESS_REG, (unsigned long long) ptable[ndev]);
#else
    iowrite32(acc_ptr[ndev], PT_ADDRESS_REG, (unsigned) ptable[ndev]);
#endif
    iowrite32(acc_ptr[ndev], PT_NCHUNK_REG, NCHUNK(mem_size[ndev]));
    iowrite32(acc_ptr[ndev], PT_SHIFT_REG, CHUNK_SHIFT);
    //printf("Checkpoint3\n");
    // Use the following if input and output data are not allocated at the default offsets
    iowrite32(acc_ptr[ndev], SRC_OFFSET_REG, 0x0);
    iowrite32(acc_ptr[ndev], DST_OFFSET_REG, 0x0);
    //printf("Checkpoint4\n");
    // Pass accelerator-specific configuration parameters
    /* <<--regs-config-->> */
    config_acc_param(acc_ptr[ndev], acc_type);
    //printf("Checkpoint8 - overcame config_acc_param\n");
    // Flush (customize coherence model here)
    esp_flush(coherence);
    //printf("Checkpoint9 - overcame esp_flush\n");
}

//------------------Starting Functions
void run_acc(int ndev)
{
    // Start accelerators
    //printf("  Start...\n");
    iowrite32(acc_ptr[ndev], CMD_REG, CMD_MASK_START);
}
